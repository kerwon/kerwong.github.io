<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Markdown 语法简单小结]]></title>
      <url>%2F2016%2F12%2FMarkdown-%E8%AF%AD%E6%B3%95%E7%AE%80%E5%8D%95%E5%B0%8F%E7%BB%93%2F</url>
      <content type="text"><![CDATA[写在前面最终，我的博客还是回归到了起点。博客断断续续几年，尽是折腾界面美化和各种网站框架或者建站工具，最终，失去了其核心价值，即内容和思想的沉淀。这更使得我的博客流于表面，对于自己的成长，也没有起到太多正面的作用。 反思后，决心回归最简单的格式外观，将重点集中于高质量内容的沉淀上。 这也是为什么又回到了 Markdown 的怀抱。 至于编辑器，我用过了众多纯编辑器，众多 Web 版的富文本编辑器，以及许许多多Markdown 编辑器后，决定使用最的 Vim。同时，也推荐一款 Markdown 编辑器Typora。这款软件足够轻量级，同时功能做到了尽可能的简单。至于 Web 编辑器，我使用简书。 Markdown 概述 Markdown 是一种轻量级的 “标记语言”，创始人为约翰·格鲁伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。——Wikipedia Markdown 拥有这众多的优点 纯文本编辑 学习成本低 广泛的软件支持 在码农界有深厚的基础 基础语法强调星号与下划线都可以，单是斜体，双是粗体，符号可跨行，符号可加空格 代码 效果 *这是斜体* 这是斜体 _这是斜体_ 这是斜体 **这是粗体** 这是粗体 __这是粗体__ 这是粗体 标题代码:123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果如下： 一级标题二级标题三级标题四级标题五级标题六级标题 注意 最后一个 # 字符与标题中间要留有一个空格 标题共提供 6 级 一般行文中，标题应置于行首。若置于表格中，可能无法正确解析 引用Markdown 中引用通过符号 ‘&gt;’ 来实现。’&gt;’ 符号后的空格，可有可无。在引用的区块内，允许换行存在，换行并不会终止引用的区块。如果要结束引用，需要一行空白行，来结束引用的区块。 代码：123456&gt; 这是一句引用&gt; 这句仍然在引用区块内&gt;&gt; 这是一句嵌套引用&gt;&gt; 这句仍然在嵌套引用区块内&gt;&gt; 另起一行的引用。前面需要一个视觉上的空行表示内层嵌套的结束，空行前面的(&apos;&gt;&apos;)可以有可以没有。 效果如下： 这是一句引用这句仍然在引用区块内 这是一句嵌套引用这句仍然在嵌套引用区块内 另起一行的引用。前面需要一个视觉上的空行表示内层嵌套的结束，空行前面的(‘&gt;’)可以有可以没有。 列表有序列表数字不能省略但可无序，点号之后的空格不能少。虽然下面代码的序号是 1，2，4，但是在显示时，仍然为自然数序列，并不是完成与编号一致。同样的，在列表的最后需要留有一行空行，以表达列表的结束，不然将作为一个无编号的列表存在。 代码：1231. 列表 A2. 列表 B4. 列表 C 效果如下： 列表 A 列表 B 列表 C 无序列表符号之后的空格不能少，-+*效果一样，但不能混合使用 代码：12345678- 列表 A1- 列表 B1+ 列表 A2+ 列表 B2* 列表 A3* 列表 B3 效果如下： 列表 A1 列表 B1 列表 A2 列表 B2 列表 A3 列表 B3 嵌套列表有序与无序，以及有序和无序列表本身都是可以自由的嵌套的。Markdown 中的列表嵌套，通过在符号前增加空格来表示。同一级别下，前面的空格数目应该保持一致。每递进一级，我习惯上使用 2 个空格缩进来表示。 代码：123456- 一级列表 A- 一级列表 B - 二级列表 A * 二级列表 B + 三级列表 A- 一级列表 C 效果如下： 一级列表 A 一级列表 B 二级列表 A 二级列表 B 三级列表 A 一级列表 C 注意，有序列表的嵌套，也是通过预留空格实现 有序一级列表 A 有序一级列表 B 有序二级列表 A 有序二级列表 B 无序三级列表 A 无序三级列表 B 有序一级列表 C 分割线三个或更多-_*，必须单独一行，可含空格。例如以下形式，都可以表示为分割线。 代码：1234567---- - -____ __**** ** * * * 进阶语法超链接图片与链接，在 Markdown 语法中表达类似，都是 [链接文字](链接地址) 这样的形式。 普通链接代码：12[Wikipedia Markdown 条目](https://zh.wikipedia.org/wiki/Markdown)[Wikipedia Markdown 条目](https://zh.wikipedia.org/wiki/Markdown &quot;Markdown 条目&quot;) 效果如下：Wikipedia Markdown 条目Wikipedia Markdown 条目 图片链接图片需要在 [] 前增加一个 ! 以使得图片在网页上直接显示，而不仅仅是个链接形式。 代码:12![维基百科 Logo](https://zh.wikipedia.org/static/images/project-logos/zhwiki.png)![维基百科 Logo](https://zh.wikipedia.org/static/images/project-logos/zhwiki.png &quot;维基 Logo&quot;) 效果如下： 上面分别有两个超链接和两张图片，两个超链接的区别在于一个增加了说明注释，而另一个没有，图片同理。 索引链接索引链接，本质上与前两种链接一致，只是索引链接将 [链接文字](链接地址) 分离为[链接文字][索引], [索引]:链接地址 的形式。 代码：12[Wikipedia Markdown 条目][1][1]:https://zh.wikipedia.org/wiki/Markdown 效果如下：Wikipedia Markdown 条目 表格对于表格的支持，要根据具体的 Markdown 解释器来判定。在 hexo 中，支持以下 Markdown 形式的表格。需要注意以下几点： 表格第一行为标题，样式会被特殊处理 | 前后要留有空格 只要是三个 - 字符表示分隔线 通过 : 来区分，左对齐、居中、右对齐 代码：1234| 1 | 2 | 3 || --- |:---:| ---:|| aaa | bbbbbb | c || aaaaaa | b | ccc | 效果如下： 1 2 3 aaa bbbbbb c aaaaaa b ccc 代码行内代码如果要标记一小段行内代码，可以用反引号 ` 把它包起来 代码：1这是一段行内代码，`System.out.println(&quot;article id: &quot; + articleId);` 摘自 Redis 工程。 效果如下： 这是一段行内代码，System.out.println(&quot;article id: &quot; + articleId); 摘自 Redis 工程。 区块代码如果要成块的引用代码，有两种方法，一种是用制表符缩进，另一种，则是用三个反引号 ```，将代码块包起来。在三个反引号后，加上语言说明，例如 ```java 这样，便指定了之后的代码采用 java 的高亮。 效果如下：123456789101112131415161718public int genRandPost(int bound) &#123; Random rand = new Random(); int cnt = rand.nextInt(bound); Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); long articleId; for (int i = 0; i &lt; cnt; i++) &#123; articleId = jedis.incr("article:"); map.put("author", "author" + i); map.put("article", "This is article " + i); jedis.hmset("article:" + articleId, map); map.clear(); &#125; System.out.println("Insert " + cnt + " posts."); return cnt;&#125; 公式大神提供了 hexo 下自动部署 MathJax 插件。安装好插件后，遍可以使用 \(LaTex\) 来显示数学公式了。在行内输入公式，需要在公式前后加上两个反斜杠 ‘\’ 以及一个括号，前后两个括号要成对。而独立成行的公式，则使用两个美元符 ‘$’。 代码：123456789101112在行内插入公式 \\(x=\frac&#123;-b\pm\sqrt&#123;b^2-4ac&#125;&#125;&#123;2a&#125;\\) 是这样的。$$x=\frac&#123;-b\pm\sqrt&#123;b^2-4ac&#125;&#125;&#123;2a&#125;$$$$\begin&#123;eqnarray&#125;\nabla\cdot\vec&#123;E&#125; &amp;=&amp; \frac&#123;\rho&#125;&#123;\epsilon_0&#125; \\\nabla\cdot\vec&#123;B&#125; &amp;=&amp; 0 \\\nabla\times\vec&#123;E&#125; &amp;=&amp; -\frac&#123;\partial B&#125;&#123;\partial t&#125; \\\nabla\times\vec&#123;B&#125; &amp;=&amp; \mu_0\left(\vec&#123;J&#125;+\epsilon_0\frac&#123;\partial E&#125;&#123;\partial t&#125; \right)\end&#123;eqnarray&#125;$$ 效果如下： 在行内插入公式 \(x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}\) 是这样的。 $$x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}$$ $$\begin{eqnarray}\nabla\cdot\vec{E} &amp;=&amp; \frac{\rho}{\epsilon_0} \\nabla\cdot\vec{B} &amp;=&amp; 0 \\nabla\times\vec{E} &amp;=&amp; -\frac{\partial B}{\partial t} \\nabla\times\vec{B} &amp;=&amp; \mu_0\left(\vec{J}+\epsilon_0\frac{\partial E}{\partial t} \right)\end{eqnarray}$$ 参考资料[1] Wikipedia Markdown 条目，https://zh.wikipedia.org/wiki/Markdown[2] 不如的博客，http://ibruce.info/2013/11/26/markdown/[3] Markdown 语法说明 (简体中文版)，http://wowubuntu.com/markdown/index.html[4] Markdown：让书写更美好，http://www.jianshu.com/p/17fdcf17bbb4[5] Markdown中插入数学公式的方法, http://blog.csdn.net/xiahouzuoxin/article/details/26478179]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python logging日志模块使用小结]]></title>
      <url>%2F2016%2F10%2FPython-logging%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93%2F</url>
      <content type="text"><![CDATA[在运行程序时，为了监控程序的行为需要对程序行为记录日志。 在Python 下，就有这样一个专门用来做日志记录的类库，logging 简单的将日志打印到屏幕12345678910111213141516#!/usr/bin/env python# -*- coding: utf8 -*-# -- modules --import logging# -- start --if __name__ == '__main__': # 默认情况下，logging将日志打印到屏幕，日志级别为WARNING # 日志级别大小关系为：CRITICAL &gt; ERROR # &gt; WARNING &gt; INFO &gt; DEBUG &gt; NOTSET logging.debug('DEBUG') # 屏幕不显示 logging.info('INFO') # 屏幕不显示 logging.warning('WARNING') 屏幕输出1234567891011121314151617181920212223242526wang@Wang:~/Workspace/Python/Template/logger$ ./logger1.pyWARNING:root:WARNING通过logging.basicConfig 函数对日志的输出格式及方式做相关配置#!/usr/bin/env python# -*- coding: utf8 -*-# -- modules --import logging# -- start --if __name__ == &apos;__main__&apos;: logging.basicConfig(level=logging.DEBUG, format=&apos;[%(asctime)s] %(filename)s [line:%(lineno)d] [%(levelname)s] %(message)s&apos;, datefmt=&apos;%a, %d %b %Y %H:%M:%S&apos;, filename=&apos;test.log&apos;, filemode=&apos;w&apos;) logging.exception(&apos;This is EXCEPTION&apos;) try: 1/0 except Exception, e: logging.exception(&apos;This is EXCEPTION [%s]&apos; % e) logging.critical(&apos;This is CRITICAL&apos;) logging.error(&apos;This is ERROR&apos;) logging.warning(&apos;This is WARNING&apos;) logging.info(&apos;This is INFO&apos;) logging.debug(&apos;This is DEBUG&apos;) 配置完成后，日志输出至test.log 日志文件 注意：由于日志写入模式设置为’w ‘，因此重复运行时会将之前的日志清空。 logging.basicConfig 函数各参数:123456789101112131415161718filename: 指定日志文件名filemode: 和file函数意义相同，指定日志文件的打开模式，’w’或’a’format: 指定输出的格式和内容，format可以输出很多有用信息，如上例所示:%(levelno)s: 打印日志级别的数值%(levelname)s: 打印日志级别名称%(pathname)s: 打印当前执行程序的路径，其实就是sys.argv[0]%(filename)s: 打印当前执行程序名%(funcName)s: 打印日志的当前函数%(lineno)d: 打印日志的当前行号%(asctime)s: 打印日志的时间%(thread)d: 打印线程ID%(threadName)s: 打印线程名称%(process)d: 打印进程ID%(message)s: 打印日志信息datefmt: 指定时间格式，同time.strftime()level: 设置日志级别，默认为logging.WARNINGstream: 指定将日志的输出流，可以指定输出到sys.stderr,sys.stdout或者文件，默认输出到sys.stderr，当stream和filename同时指定时，stream被忽略 日志输出内容如下：123456789101112[Mon, 15 Apr 2013 22:37:28] logger2.py [line:14] [ERROR] This is EXCEPTIONNone[Mon, 15 Apr 2013 22:37:28] logger2.py [line:18] [ERROR] This is EXCEPTION [integer division or modulo by zero]Traceback (most recent call last):File &quot;./logger2.py&quot;, line 16, in &lt;module&gt;1/0ZeroDivisionError: integer division or modulo by zero[Mon, 15 Apr 2013 22:37:28] logger2.py [line:19] [CRITICAL] This is CRITICAL[Mon, 15 Apr 2013 22:37:28] logger2.py [line:20] [ERROR] This is ERROR[Mon, 15 Apr 2013 22:37:28] logger2.py [line:21] [WARNING] This is WARNING[Mon, 15 Apr 2013 22:37:28] logger2.py [line:22] [INFO] This is INFO[Mon, 15 Apr 2013 22:37:28] logger2.py [line:23] [DEBUG] This is DEBUG 特别指出EXCEPTION 在日志中输出为ERROR ，但是会多输出一行错误信息，如果没有设置，则输出None 。如日志第一条 EXCEPTION 的正确用法是嵌套在except: 中，并用以输出错误信息。 要指出的是，错误信息会为EXCEPTION 保持，即使在logging.debug() 后logging.exception(‘X’) 那么仍会输出原来未改变的错误信息，即输出1234[Mon, 15 Apr 2013 xx:xx:xx] logger2.py [line:18] [ERROR] X [integer division or modulo by zero]Traceback (most recent call last):File &quot;./logger2.py&quot;, line 16, in &lt;module&gt;1/0 将日志同时输出到文件和屏幕1234567891011121314151617181920212223#!/usr/bin/env python# -*- coding: utf8 -*-# -- modules --import logging# -- start --if __name__ == '__main__': logging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(filename)s [line:%(lineno)d] %(levelname)s %(message)s', datefmt='%a, %d %b %Y %H:%M:%S', filename='test.log', filemode='w') console = logging.StreamHandler() console.setLevel(logging.WARNING) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) logging.debug('This is DEBUG') logging.info('This is INFO') logging.warning('This is WARNING') 注意：basicConfig中设置的为写入文件的日志级别，但是在屏幕输出的内容级别需要额外设置 屏幕输出为：123456root : WARNING This is WARNING日志文件输出为：Tue, 16 Apr 2013 16:57:21 logger3.py [line:21] DEBUG This is DEBUGTue, 16 Apr 2013 16:57:21 logger3.py [line:22] INFO This is INFOTue, 16 Apr 2013 16:57:21 logger3.py [line:23] WARNING This is WARNING logging之日志回滚略，没看懂。。 通过logging.config模块配置日志123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221# --- logconf.ini -----------------------------------------------------------# &quot;loggers&quot;模块包含logger配置的所有关键字，这些关键字并非是直接的配置文件模块名# 但是，却是Python脚本调用时会使用到的名字。# 单独的模块名命名为&quot;logger_xxx&quot; 其中&quot;xxx&quot;部分为&quot;key&quot;# 例如 &quot;logger_root&quot;, &quot;logger_log02&quot;[loggers]keys=root,log02,log03,log04,log05,log06,log07# &quot;handlers&quot; 模块包含所有的 handler 配置# keys的使用方式同loggers[handlers]keys=hand01,hand02,hand03,hand04,hand05,hand06,hand07,hand08,hand09# &quot;formatters&quot; 模块包含所有的 formatter 配置# keys的使用方式同loggers[formatters]keys=form01,form02,form03,form04,form05,form06,form07,form08,form09[logger_root]level=NOTSET # DEBUG, INFO, WARN, ERROR, CRITICAL 或 NOTSET# NOTSET: 如果 propagate=1, 输出参考 parent, 否则, 全部输出handlers=hand01qualname=(root) # root比较特殊, root需要加(), 别的不需要propagate=1 # 此参数为非root logger使用channel=parent=[logger_log02]level=DEBUGpropagate=1qualname=log02 # qualname 填写全称handlers=hand02 # 使用的 handler 名称channel=log02 # channel表示最末端部分名称parent=(root) # 父logger为root[logger_log03]level=INFOpropagate=1 # 如果 propagate=1, 输出参考 parentqualname=log02.log03 # 由于其 parent 为 log02, 所以全称为 log02.log03handlers=hand03channel=log03 # 填写最末名称, log02.log03 最后为 log03parent=log02[logger_log04]level=WARNpropagate=0qualname=log02.log03.log04handlers=hand04channel=log04parent=log03[logger_log05]level=ERRORpropagate=1qualname=log02.log03.log04.log05handlers=hand05channel=log05parent=log04[logger_log06]level=CRITICALpropagate=1qualname=log02.log03.log04.log05.log06handlers=hand06channel=log06parent=log05[logger_log07]level=WARNpropagate=1qualname=log02.log03.log04.log05.log06.log07handlers=hand07channel=log07parent=log06[handler_hand01]class=StreamHandler # 实例发送错误到流(类似文件的对象)level=NOTSET # NOTSET 表示 level 参考 parentformatter=form01args=(sys.stdout,) # args 为传给 handler 构造函数的参数stream=sys.stdout[handler_hand02]class=FileHandler # 实例发送错误到磁盘文件level=DEBUGformatter=form02args=(&apos;python.log&apos;, &apos;w&apos;)filename=python.logmode=w[handler_hand03]class=handlers.SocketHandler # 实例发送日志到TCP/IP socketlevel=INFOformatter=form03args=(&apos;localhost&apos;, handlers.DEFAULT_TCP_LOGGING_PORT)host=localhostport=DEFAULT_TCP_LOGGING_PORT[handler_hand04]class=handlers.DatagramHandler # 实例发送错误信息通过UDP协议level=WARNformatter=form04args=(&apos;localhost&apos;, handlers.DEFAULT_UDP_LOGGING_PORT)host=localhostport=DEFAULT_UDP_LOGGING_PORT[handler_hand05]class=handlers.SysLogHandler # 实例发送日志到UNIX syslog服务，并支持远程syslog服务level=ERRORformatter=form05args=((&apos;localhost&apos;, handlers.SYSLOG_UDP_PORT), handlers.SysLogHandler.LOG_USER)host=localhostport=SYSLOG_UDP_PORTfacility=LOG_USER[handler_hand06]class=NTEventLogHandler # 实例发送日志到WindowsNT/2000/XP事件日志level=CRITICALformatter=form06args=(&apos;Python Application&apos;, &apos;&apos;, &apos;Application&apos;)appname=Python Applicationdllname=logtype=Application[handler_hand07]class=SMTPHandler # 实例发送错误信息到特定的email地址level=WARNformatter=form07args=(&apos;localhost&apos;, &apos;from@abc&apos;, [&apos;user1@abc&apos;, &apos;user2@xyz&apos;], &apos;Logger Subject&apos;)host=localhostport=25from=from@abcto=user1@abc,user2@xyzsubject=Logger Subject[handler_hand08]class=MemoryHandler # 实例发送日志到内存中的缓冲区，并在达到特定条件时清空level=NOTSETformatter=form08target=args=(10, ERROR)capacity=10flushlevel=ERROR[handler_hand09]class=HTTPHandler # 实例发送错误信息到HTTP服务器，通过GET或POST方法level=NOTSETformatter=form09args=(&apos;localhost:9022&apos;, &apos;/log&apos;, &apos;GET&apos;)host=localhostport=9022url=/logmethod=GET[handler_hand010]# BaseRotatingHandler是所有轮徇日志的基类，不能直接使用。# 但是可以使用RotatingFileHandler和TimeRotatingFileHandler。class=handlers.RotatingFileHandler # 实例发送信息到磁盘文件，并且限制最大的日志文件大小，并适时轮徇level=INFOformatter=form02args=(&apos;test.log&apos;, &apos;a&apos;, 10*1024*1024, 5)###############################################################################[formatter_form01]format=F1 %(asctime)s %(levelname)s %(message)sdatefmt=[formatter_form02]format=F2 %(asctime)s %(pathname)s(%(lineno)d): %(levelname)s %(message)sdatefmt=[formatter_form03]format=F3 %(asctime)s %(levelname)s %(message)sdatefmt=[formatter_form04]format=%(asctime)s %(levelname)s %(message)sdatefmt=[formatter_form05]format=F5 %(asctime)s %(levelname)s %(message)sdatefmt=[formatter_form06]format=F6 %(asctime)s %(levelname)s %(message)sdatefmt=[formatter_form07]format=F7 %(asctime)s %(levelname)s %(message)sdatefmt=[formatter_form08]format=F8 %(asctime)s %(levelname)s %(message)sdatefmt=[formatter_form09]format=F9 %(asctime)s %(levelname)s %(message)sdatefmt=# --- end of logconf.ini ----------------------------------------------------logging在低版本（如 2.3.4）中用法有少许差别def initial_logger(): import logging LOG_FILENAME = &apos;test.log&apos; logger = logging.getLogger() handler = logging.FileHandler(LOG_FILENAME) formatter = logging.Formatter(&apos;[%(asctime)s] %(filename)s[line:%(lineno)d] [%(levelname)s] %(message)s&apos;, &apos;%Y-%m-%d %H:%M:%S&apos;) handler.setFormatter(formatter) logger.addHandler(handler) logger.setLevel(logging.NOTSET) return loggerdef main(): logger = initial_logger() logger.debug(&quot;test debug&quot;)if __name__ == &apos;__main__&apos;: main()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在IDE中使用 JUnit4 进行单元测试]]></title>
      <url>%2F2016%2F10%2F%E5%9C%A8IDE%E4%B8%AD%E4%BD%BF%E7%94%A8-JUnit4-%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
      <content type="text"><![CDATA[Eclipse 下的 JUnit 使用新建项目JUnitTest，创建Calculator类编写Calculator类为了方便测试，在Calculator类 中添加一些 Bugs12345678910111213141516171819202122232425262728package com;public class Calculator &#123; private static int result; // 静态变量，用于存储运行结果 public void add(int n) &#123; result = result + n; &#125; public void substract(int n) &#123; result = result - 1; // Bug: 正确的应该是 result =result-n &#125; public void multiply(int n) &#123; &#125; // 此方法尚未写好 public void divide(int n) &#123; result = result / n; &#125; public void square(int n) &#123; result = n * n; &#125; public void squareRoot(int n) &#123; for (;;) ; // Bug : 死循环 &#125; public void clear() &#123; // 将结果清零 result = 0; &#125; public int getResult() &#123; return result; &#125;&#125; 将JUnit4单元测试包引入这个项目在JUnitTest 项目上，单击右键，选择 Properties （属性） 在弹出的属性窗口中，首先在左边选择“Java Build Path ”，然后到右上选择“Libraries ”标签，之后在最右边点击“Add Library… ”按钮，如下图所示：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用 PyUnit 构建 Python单元测试]]></title>
      <url>%2F2016%2F10%2F%E4%BD%BF%E7%94%A8-PyUnit-%E6%9E%84%E5%BB%BA-Python%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
      <content type="text"><![CDATA[概况Python 单元测试框架（The Python unit testing framework） ，简称为PyUnit ， 是 Kent Beck 和 Erich Gamma 这两位聪明的家伙所设计的 JUnit 的Python 版本。此文档仅阐述针对Python 的单元测试PyUnit 的设计与使用。自从 Python 2.1 版本后，PyUnit 成为 Python 标准库的一部分。 系统要求PyUnit 可以在Python 1.5.2 及更高版本上运行。 使用PyUnit构建自己的测试安装编写测试所需的类可以在“unittest” 模块中找到。此模块是Python 2.1 和更高版本的标准库的一部分。为使此模块能在你的代码中正常工作,你只需确保包含 unittest.py 文件的目录在你的Python 搜索路径中。 注意，只有完成此项工作才能运行PyUnit 所自带的例子，除非将 unittest.py 复制到例子目录。 测试用例介绍单元测试是由一些测试用例（Test Cases） 构建组成的。测试用例是被设置用来检测正确性的单独的场景。在PyUnit 中，unittest 模块中的TestCase 类 代表测试用例。TestCase类 的实例是可以完全运行测试方法和可选的设置（set-up） 以及清除（tidy-up） 代码的对象。TestCase 实例的测试代码必须是自包含的，换言之，它可以单独运行或与其它任意数量的测试用例共同运行。 以下测试皆为对此类测试 12345678910111213141516#!/usr/bin/env python# -*- coding: utf-8 -*-## -- class &amp; functions --class Widget: '''need to test''' def __init__(self, size = (40, 40)): self._size = size def getSize(self): return self._size def resize(self, width, height): if width &lt; 0 or height &lt; 0: raise VauleError, "illegal size" self._size = (width, height+1) def dispose(size): pass 创建一个简单测试用例通过覆盖runTest方法即可得到最简单的测试用例子类以运行 一些测试代码：1234567891011121314# 静态方法# 采用静态方法，要为每个要测试的方法编写一个测试类# （该类通过覆盖runTest()方法来执行测试），# 并在每一个测试类中生成一个待测试的对象。class WidgetSizeTestCase(unittest.TestCase): def runTest(self): widget = Widget() self.assertEqual(widget.getSize(), (40, 40))class WidgetResizeTestCase(unittest.TestCase): def runTest(self): widget = Widget() widget.resize(100, 100) self.assertEqual(widget.getSize(), (100, 100)) 注意：为进行测试，我们只是使用了Python 内建的“assert ”语句。如果在测试用例运行时断言（assertion ）为假，AssertionError 异常会被抛出，并且测试框架会认为测试用例失败。其它非“assert ”检查所抛出的异常会被测试框架认为是“errors ”。 运行测试用例的方法会在后面介绍。现在我们只是通过调用无参数的构造器（constructor） 来创建一个测试用例的实例：1testCase = WidgetSizeTestCase() 复用设置代码：创建固件这样的测试用例数量巨大且它们的设置需要很多重复性工作。在上面的测试用例中， 如若在100个Widget 测试用例的每一个子类中都创建一个“Widget ”，那会导致难看的重复。幸运的是，我们可以将这些设置代码提取出来并放置在一个叫做setUp 的 钩子方法（hook method） 中。测试框架会在运行测试时自动调用此方法：123456789101112131415161718import unittestclass SimpleWidgetTestCase(unittest.TestCase): def setUp(self): self.widget = Widget("The widget") def tearDown(self): self.widget.dispose() self.widget = Noneclass WidgetSizeTestCase(SimpleWidgetTestCase): def runTest(self): widget = Widget() self.assertEqual(widget.getSize(), (40, 40))class WidgetResizeTestCase(SimpleWidgetTestCase): def runTest(self): widget = Widget() widget.resize(100, 100) self.assertEqual(widget.getSize(), (100, 100)) 如果setUp 方法在测试运行时抛出异常，框架会认为测试遇到了错误并且 runTest 不会被执行。类似的，我们也可以提供一个tearDown 方法来完成在runTest 运行之后的清理工作。如果setUp 执行成功， 那么无论runTest 是否成功，tearDown 方法都将被执行。 Such a working environment for the testing code is termed a fixture. 这个测试代码的运行环境被称为固件 (fixture，译者注：此为暂定译法，意为固定的构件或方法)。 包含多个测试方法的测试用例类很多小型测试用例经常会使用相同的固件。在这个用例中，我们最终从SimpleWidgetTestCase 继承产生很多仅包含一个方法的类，如 DefaultWidgetSizeTestCase 。这是很耗时且不被鼓励的，因此，沿用JUnit 的风格，PyUnit 提供了一个更简便的方法：1234567891011121314151617# 动态方法class WidgetTestCase(unittest.TestCase): # 执行测试类 # dynamic 测试方法 # 覆盖unittest中 setUp, 在其中完成初始化 # 覆盖unittest中tearDown, 释放资源 # dynamic 测试不需要覆盖 runTest 方法 def setUp(self): self.widget = Widget(); def tearDown(self): self.widget.dispose() self.widget = None def testSize(self): self.assertEqual(self.widget.getSize(), (40, 40)) def testResize(self): self.widget.resize(100, 100) self.assertEqual(self.widget.getSize(), (100, 100)) 在这个用例中，我们没有提供runTest 方法，而是两个不同的测试方法。类实例将创建和销毁各自的self.widget 并运行某一个test 方法。 当创建类实例时，我们必须通过向构造器传递方法的名称来指明哪个测试方法将被运行：12defaultSizeTestCase = WidgetTestCase("testSize")resizeTestCase = WidgetTestCase("testResize") 将测试用例聚合成测试套件测试用例实例可以根据它们所测试的特性组合到一起。PyUnit 为此提供了一个机制叫做”测试套件“（test suite) 。它由unittest模块 中的TestSuite类 表示,在每个测试模块中提供一个返回已创建测试套件的可调用对象，会是一个使测试更加便捷的好方法：1234567# 测试用例集, 方法一# 全局函数def suite(): suite = unittest.TestSuite() suite.addTest(WidgetTestCase("testSize")) suite.addTest(WidgetTestCase("testResize")) return suite 甚至可写成:12345678# 测试用例集, 方法二# 定义 TestSuite 子类class WidgetTestSuite(unittest.TestSuite): def __init__(self): unittest.TestSuite.__init__(self, map(WidgetTestCase,("testSize","testResize"))) def suite(): return WidgetTestSuite() 因为创建一个包含很多相似名称的测试方法的TestCase 子类是一种很常见的模式，所以unittest模块 提供一个便捷方法，makeSuite ，来 创建一个由测试用例类内所有测试用例组成的测试套件：12345# 测试用例集, 方法三# 如果用于测试的类中所有的测试方法都以test开头，# Python程序员可以用PyUnit模块提供的makeSuite()方法来构造一个TestSuitedef suite(): return unittest.makeSuite(WidgetTestCase, "test") 需要注意的是，当使用makeSuite 方法时，测试套件运行每个测试用例的顺序是由测试方法名根据Python 内建函数cmp 所排序的顺序而决定的。 嵌套测试套件我们经常希望将一些测试套件组合在一起来一次性的测试整个系统。这很简单，因为多个TestSuite 可以被加入进另一个TestSuite ，就如同 多个TestCase 被加进一个TestSuite 中一样：123suite1 = module1.TheTestSuite()suite2 = module2.TheTestSuite()alltests = unittest.TestSuite((suite1, suite2)) 测试代码放置位置可以将测试用例定义与被测试代码置于同一个模块中（例如“widget.py ”），但是将测试代码放置在单独的模块中（如“widgettests.py ”）会有一些优势： 测试模块可以从命令行单独执行 测试代码可以方便地从发布代码中分离 少了在缺乏充足理由的情况下为适应被测试代码而更改测试代码的诱惑 相对于被测试代码，测试代码不应该被频繁的修改 被测试代码可以更方法的进行重构 既然C语言代码的测试应该置于单独的模块，那何不保持这个一致性呢？ 如果测试策略改变，也无需修改被测试源代码 交互式运行测试 我们编写测试的主要目的是运行它们并检查我们的软件是否工作正常。测试框架使用“TestRunner”类 来为运行测试提供环境。最常用的TestRunner 是TextTestRunner ， 它可以以文字方式运行测试并报告结果：1234567891011121314# 实施测试# PyUnit使用TestRunner类作为测试用例的基本执行环境，# 来驱动整个单元测试过程。# Python开发人员在进行单元测试时一般不直接使用TestRunner类，# 而是使用其子类TextTestRunner来完成测试，并将测试结果以文本方式显示出来# -- start --if __name__ == '__main__': # 构造测试集 suite = suite() # 执行测试 runner = unittest.TextTestRunner() runner.run(suite) TextTestRunner 默认将输出发送到sys.stderr ，但是你可以通过向它的构造器传递一个不同的类似文件（file-object ）对象来改变默认方式。如需在Python 解释器会话中运行测试，这样使用TextTestRunner 是一个理想的方法。 更多关于测试条件建议过应使用Python 内建断言机制来检查测试用例中的条件，而不应使用自己编写的替代品，因为assert 更简单，简明且为大家所熟悉。但是值得注意的是，如果在运行测试的同时Python 优化选项被打开（生成“.pyo ”字节码文件），那么assert 语句将会被跳过，使得测试用例变得无用。我为那些需要使用Python 优化选项的用户编写了一个 assert 方法并添加进TestCase类 内。它的功能和内建的assert 相同且 不会被优化删除，但是使用较麻烦且所输出错误信息帮助较小：12def runTest(self): self.assert_(self.widget.size() == (100,100), "size is wrong") 我还在TestCase类 中提供了failIf 和failUnless 两个方法：12def runTest(self): self.failIf(self.widget.size() &lt;&gt; (100,100)) 测试方法还可以通过调用fail 方法使得测试立即失败：12345def runTest(self): ... if not hasattr(something, "blah"): self.fail("blah missing") # or just 'self.fail()' 测试相等性最常用的断言是测试相等性。如果断言失败，开发者通常希望看到实际错误值。TestCase 包含一对方法assertEqual 和assertNotEqual 用于此目的(如果你喜欢，你还可以使用别名：failUnlessEqual 和 failIfEqual ):123def testSomething(self): self.widget.resize(100,100) self.assertEqual(self.widget.size, (100,100)) 测试异常测试经常希望检查在某个环境中是否出现异常。如果期待的异常没有抛出，测试将失败。这很容易做到：1234567def runTest(self): try: self.widget.resize(-1,-1) except ValueError: pass else: fail("expected a ValueError") 通常，预期异常源（译者注：将抛出异常的代码）是一个可调用对象；为此，TestCase 有一个assertRaises 方法。此方法的前两个参数是应该出现在“except ”语句中的异常和可调用对象。剩余的参数是应该传递给可调用对象的参数。12def runTest(self): self.assertRaises(ValueError, self.widget.resize, -1, -1) 附录完整测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#!/usr/bin/env python# -*- coding: utf-8 -*-## Copyright © 2013 Al™, All Rights Reserved.#'''Created on 2013/03/21 14:48:49@module: unitest_test.py@version:@license: Copyright © 2013 Al™, All Rights Reserved.@author: Wang Wenchao@contact: U&#123;B&#123;Wang Wenchao&#125;&#125;@see:@note:'''# -- modules --from testmodule import Widgetimport unittest# -- global --# -- class &amp; functions --# ============================================================================# 静态方法# 采用静态方法，要为每个要测试的方法编写一个测试类# （该类通过覆盖runTest()方法来执行测试），# 并在每一个测试类中生成一个待测试的对象。#class WidgetSizeTestCase(unittest.TestCase):# def runTest(self):# widget = Widget()# self.assertEqual(widget.getSize(), (40, 40))#class WidgetResizeTestCase(unittest.TestCase):# def runTest(self):# widget = Widget()# widget.resize(100, 100)# self.assertEqual(widget.getSize(), (100, 100))# 动态方法class WidgetTestCase(unittest.TestCase): # 执行测试类 # dynamic 测试方法 # 覆盖unittest中 setUp, 在其中完成初始化 # 覆盖unittest中tearDown, 释放资源 # dynamic 测试不需要覆盖 runTest 方法 def setUp(self): self.widget = Widget(); def tearDown(self): self.widget.dispose() self.widget = None def testSize(self): self.assertEqual(self.widget.getSize(), (40, 40)) def testResize(self): self.widget.resize(100, 100) self.assertEqual(self.widget.getSize(), (100, 100))# ============================================================================# 测试用例集, 方法一# 全局函数#def suite():# suite = unittest.TestSuite()# suite.addTest(WidgetTestCase("testSize"))# suite.addTest(WidgetTestCase("testResize"))# return suite# ----------------------------------------------------------------------------# 测试用例集, 方法二# 定义 TestSuite 子类#class WidgetTestSuite(unittest.TestSuite):# def __init__(self):# unittest.TestSuite.__init__(self, map(WidgetTestCase,("testSize","testResize")))# def suite():# return WidgetTestSuite()# ----------------------------------------------------------------------------# 测试用例集, 方法三# 如果用于测试的类中所有的测试方法都以test开头，# Python程序员可以用PyUnit模块提供的makeSuite()方法来构造一个TestSuitedef suite(): return unittest.makeSuite(WidgetTestCase, "test")# ============================================================================# 实施测试# PyUnit使用TestRunner类作为测试用例的基本执行环境，# 来驱动整个单元测试过程。# Python开发人员在进行单元测试时一般不直接使用TestRunner类，# 而是使用其子类TextTestRunner来完成测试，并将测试结果以文本方式显示出来# -- start --if __name__ == '__main__': # 构造测试集 suite = suite() # 执行测试 runner = unittest.TextTestRunner() runner.run(suite) 运行输出123456789101112131415161718192021222324wang@Wang-Satellite-M300:~/Workspace/Python/Template/unittest$ ./unittest_test.pyF.======================================================================FAIL: testResize (__main__.WidgetTestCase)———————————————————————-Traceback (most recent call last):File &quot;./unittest_test.py&quot;, line 58, in testResizeself.assertEqual(self.widget.getSize(), (100, 100))AssertionError: Tuples differ: (100, 101) != (100, 100)First differing element 1:101100- (100, 101)? ^+ (100, 100)? ^———————————————————————-Ran 2 tests in 0.001sFAILED (failures=1)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[漫谈 JDBC 以及与 Spring 之整合]]></title>
      <url>%2F2016%2F10%2F%E6%BC%AB%E8%B0%88-JDBC-%E4%BB%A5%E5%8F%8A%E4%B8%8E-Spring-%E4%B9%8B%E6%95%B4%E5%90%88%2F</url>
      <content type="text"><![CDATA[介绍 JDBCJDBC 是 Java 数据库连接（Java Database Connectivity）的简称，是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，用来连接 Java 与数据库，提供了诸如查询和更新数据库中数据的方法。 JDBC 架构JDBC 的 API 支持两层和三层处理模式进行数据库访问，但一般的 JDBC 架构由两层处理模式组成： JDBC API : 提供了应用程序对 JDBC 管理器的连接。 JDBC Driver API : 提供了 JDBC 管理器对驱动程序连接。 JDBC API 使用驱动程序管理器和数据库特定的驱动程序来提供异构（heterogeneous）数据库的透明连接。 JDBC 驱动程序管理器可确保正确的驱动程序来访问每个数据源。该驱动程序管理器能够支持连接到多个异构数据库的多个并发的驱动程序。 以下是结构图，其中显示了驱动程序管理器相对于在 JDBC 驱动程序和 Java 应用程序所处的位置。 API 与类概述 JDBC API 主要位于JDK 中的java.sql 包中（之后扩展的内容位于javax.sql 包中），主要包括（斜体代表接口，需驱动程序提供者来具体实现）： DriverManager ：负责加载各种不同驱动程序（Driver ），并根据不同的请求，向调用者返回相应的数据库连接（Connection ）。Driver ：驱动程序，会将自身加载到DriverManager 中去，并处理相应的请求并返回相应的数据库连接（Connection ）。Connection ：数据库连接，负责进行与数据库间的通讯，SQL 执行以及事务处理都是在某个特定Connection 环境中进行的。可以产生用以执行SQL 的Statement 。Statement ：用以执行SQL 查询和更新（针对静态SQL 语句和单次执行）。PreparedStatement ：用以执行包含动态参数的SQL 查询和更新（在服务器端编译，允许重复执行以提高效率）。CallableStatement ：用以调用数据库中的存储过程。SQLException ：代表在数据库连接的创建和关闭和SQL语句的执行过程中发生了例外情况（即错误）。摘自 wikipedia，Java数据库连接，https://zh.wikipedia.org/wiki/Java%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5 除了以上 API ，JDBC 还提供了以下类： ResultSet : 在你使用语句对象执行 SQL 查询后，这些对象保存从数据获得的数据。它作为一个迭代器，让您可以通过它的数据来移动。 JDBC 使用基本思路 制作到数据库的连接。 创建 SQL 或 MySQL 语句。 执行 SQL 或 MySQL 查询数据库。 查看和修改所产生的记录。 J2SE 通过 JDBC 连接数据库前期准备 安装完成 Java 部署好数据库，以下采用的是 MySQL 数据库 下载相关驱动，MySQL 的 JDBC 驱动为使用的是 mysql-connector-java-5.1.32-bin.jar ，下载地址 创建 JDBC 应用程序 导入数据包 . 需要包括含有需要进行数据库编程的JDBC类 的包。大多数情况下，使用 import java.sql.* 就可以了. 注册JDBC驱动程序 . 需要初始化驱动程序，可以与数据库打开一个通信通道。 打开连接. 需要使用DriverManager.getConnection() 方法创建一个Connection 对象，它代表与数据库的物理连接。 执行查询 . 需要使用类型声明的对象建立并提交一个SQL 语句到数据库。 从结果集中提取数据 . 要求使用适当的关于ResultSet.getXXX() 方法来检索结果集的数据。 清理环境. 需要明确地关闭所有的数据库资源相对依靠JVM 的垃圾收集。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** STEP 1. Import required packages 导入数据包 */import java.sql.*;public class JDBCExample &#123; /** JDBC driver name and database URL * 定义 JDBC 驱动以及数据库地址，此处数据库为本地的 test */ static final String JDBC_DRIVER = "com.mysql.jdbc.Driver"; static final String DB_URL = "jdbc:mysql://localhost/test"; /** Database credentials * 数据库的账号、密码 * */ static final String USER = "root"; static final String PASS = ""; public static void main(String[] args) &#123; Connection conn = null; Statement stmt = null; try&#123; /** STEP 2: Register JDBC driver * 加载 JDBC 驱动程序 Driver 至 DriverManager */ Class.forName(JDBC_DRIVER); /** STEP 3: Open a connection * 通过 DB_URL, 数据库账号和密码来获取相应的数据库连接 */ System.out.println("Connecting to database..."); conn = DriverManager.getConnection(DB_URL,USER,PASS); /** STEP 4: Execute a query * 获取 connection 之后，可以创建 Statement 用来执行 SQL 语句 * 其中 结果存储在 ResultSet 结果集 */ System.out.println("Creating statement..."); stmt = conn.createStatement(); String sql; sql = "SELECT * FROM t_user"; ResultSet rs = stmt.executeQuery(sql); /** STEP 5: Extract data from result set * 通过遍历结果集顺序访问数据 * 具体是 getInt 还是 getString，请参考附录一：SQL 到 Java 的数据类型的映射*/ while(rs.next())&#123; //Retrieve by column name int id = rs.getInt("id"); String name = rs.getString("name"); int age = rs.getInt("age"); int gender = rs.getInt("gender"); //Display values System.out.println("ID: " + id + ", Name: " + name + ", Age: " + age + ", Gender: " + gender); &#125; /** STEP 6: Clean-up environment * 清理环境，需要关闭结果集、Statement 以及数据库连接 * 注意！关闭的顺序！*/ rs.close(); stmt.close(); conn.close(); &#125;catch(SQLException se)&#123; /** Handle errors for JDBC * 如果数据库操作失败，JDBC将抛出一个SQLException。 * 一般来说，此类异常很少能够恢复，唯一能做的就是尽可能详细的打印异常日记。 * 推荐的做法是将SQLException翻译成应用程序领域相关的异常（非强制处理异 * 常）并最终回滚数据库和通知用户。*/ se.printStackTrace(); &#125;catch(Exception e)&#123; //Handle errors for Class.forName e.printStackTrace(); &#125;finally&#123; //finally block used to close resources try&#123; if(stmt!=null) stmt.close(); &#125;catch(SQLException se2)&#123; &#125;// nothing we can do try&#123; if(conn!=null) conn.close(); &#125;catch(SQLException se)&#123; se.printStackTrace(); &#125; &#125; System.out.println("Goodbye!"); &#125;&#125; 以上一例为模板，以下例子仅填充123456789101112131415161718192021222324252627Connection conn = null;Statement stmt = null;PreparedStatement pstmt = null;try &#123; Class.forName(JDBC_DRIVER); conn = DriverManager.getConnection(DB_URL, USER, PASS); /* 在此填充代码 */&#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125; catch (SQLException e) &#123; e.printStackTrace();&#125; finally &#123; try &#123; if (stmt != null) stmt.close(); &#125; catch (SQLException se2) &#123; try &#123; if (conn != null) conn.close(); &#125; catch (SQLException se) &#123; se.printStackTrace(); &#125; &#125;&#125; Example 1：executeQuery()，仅单行数据返回一个 ResultSet 对象。当希望得到一个结果集时使用该方法，如使用 SELECT 语句。1234567891011//////// Example 1: statement, executeQuerystmt = conn.createStatement();String sql1 = "SELECT COUNT(DISTINCT `name`) AS 'cnt' FROM `user`";ResultSet rs = stmt.executeQuery(sql1);while (rs.next()) &#123; int cnt1 = rs.getInt(1); // 此处的 column，第一列下标为 1，而非 0 int cnt2 = rs.getInt("cnt"); System.out.println("count: " + cnt1 + ", " + cnt2);&#125;rs.close(); Example 2：executeUpdate()返回执行 SQL 语句影响的行的数目。使用该方法来执行 SQL 语句，得到一些受影响的行的数目，例如，INSERT，UPDATE 或 DELETE 语句123//////// Example 2: statement, executeUpdateString sql2 = "INSERT INTO `user`(name, age) VALUES ('noname', 30)";int ret2 = stmt.executeUpdate(sql2); Example 3：execute()如果 ResultSet 对象可以被检索，则返回的布尔值为 true ，否则返回 false 。当需要使用真正的动态 SQL 时，可以使用这个方法来执行 SQL DDL 语句。123//////// Example 3: statement, executeString sql3 = "CREATE TABLE tmp(id int,name VARCHAR(255))";boolean ret3 = stmt.execute(sql3); Example 4：PrepareStatement使用问号作为参数的标示。进行参数设置与大部分Java API中下标的使用方法不同，字段的下标从1开始，1代表第一个问号123456789101112/////// Example 4: preparedStatementString sql4 = "SELECT * FROM `user` WHERE name=? AND age=?";pstmt = conn.prepareStatement(sql4);pstmt.setString(1, "test");pstmt.setInt(2, 10);ResultSet rs4 = pstmt.executeQuery();while (rs4.next()) &#123; String name = rs4.getString("name"); int age = rs4.getInt("age"); System.out.println("Name: " + name + ", " + "Age: " + age);&#125;rs4.close(); Example 5：JDBC 下的事务1234567891011121314151617181920212223242526272829303132333435363738394041424344454647///////// Example 5: 事务与回滚 transaction and rollbackboolean autoCommitDefault = false;Savepoint savepoint1 = null;Savepoint savepoint2 = null;try &#123; Class.forName(JDBC_DRIVER); conn = DriverManager.getConnection(DB_URL, USER, PASS); autoCommitDefault = conn.getAutoCommit(); // 关闭自动提交，数据库默认时，是自动提交的 conn.setAutoCommit(false); stmt = conn.createStatement(); String sql5 = "SELECT * FROM `user` WHERE age=10"; String sql6 = "INSERT INTO `user`(name, age) VALUES ('name1',1),('name2', 2)"; String sql7 = "UPDATE `user` SET `name`='newname' WHERE age=10"; stmt.executeQuery(sql5); savepoint1 = conn.setSavepoint("Savepoint1"); stmt.executeUpdate(sql6); savepoint2 = conn.setSavepoint("Savepoint2"); stmt.executeUpdate(sql7); conn.commit();&#125; catch (Throwable e) &#123; try &#123; // 回滚, 至 savepoint2. savepoint 非必须 conn.rollback(savepoint2); &#125; catch (Throwable ignore) &#123;&#125; throw e;&#125; finally &#123; try &#123; // 将 commit 设回默认值 conn.setAutoCommit(autoCommitDefault); &#125; catch (Throwable ignore) &#123;&#125; try &#123; if (stmt != null) stmt.close(); &#125; catch (SQLException se2) &#123; try &#123; if (conn != null) conn.close(); &#125; catch (SQLException se) &#123; se.printStackTrace(); &#125; &#125;&#125; Example 6：JDBC 下的存储过程 TODO 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* * 有IN 类型的参数输入 和Out类型的参数输出 */public static void inOutTest()&#123; Connection connection = null; Statement statement = null; ResultSet resultSet = null; try &#123; Class.forName("oracle.jdbc.driver.OracleDriver").newInstance(); Driver driver = DriverManager.getDriver(URL); Properties props = new Properties(); props.put("user", USER_NAME); props.put("password", PASSWORD); connection = driver.connect(URL, props); //获得Statement对象,这里使用了事务机制，如果创建存储过程语句失败或者是执行compile失败，回退 connection.setAutoCommit(false); statement = connection.createStatement(); String procedureString = "CREATE OR REPLACE PROCEDURE get_job_min_salary_proc(" +"input_job_id IN VARCHAR2," +"output_salary OUT number) AS " +"BEGIN " +"SELECT min_salary INTO output_salary FROM jobs WHERE job_id = input_job_id; " +"END get_job_min_salary_proc;"; //1 创建存储过程,JDBC 数据库会编译存储过程 statement.execute(procedureString); //成功则提交 connection.commit(); //2.创建callableStatement CallableStatement callableStatement = connection.prepareCall("CALL get_job_min_salary_proc(?,?)"); //3，设置in参数 callableStatement.setString(1, "AD_PRES"); //4.注册输出参数 callableStatement.registerOutParameter(2, Types.NUMERIC); //5.执行语句 callableStatement.execute(); BigDecimal salary = callableStatement.getBigDecimal(2); System.out.println(salary); &#125; catch (ClassNotFoundException e) &#123; System.out.println("加载Oracle类失败！"); e.printStackTrace(); &#125; catch (SQLException e) &#123; try &#123; connection.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125;finally&#123; //使用完成后管理链接，释放资源，释放顺序应该是： ResultSet -&gt;Statement -&gt;Connection try &#123; statement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring 与 MyBatis 的集成详解]]></title>
      <url>%2F2016%2F10%2FSpring-%E4%B8%8E-MyBatis-%E7%9A%84%E9%9B%86%E6%88%90%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[前言 MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 —— 摘自 MyBatis 中文官网 Spring 与 MyBatis 的集成MyBatis 与 Spring 的集成思路，总共有以下几个步骤： 引入 MyBatis 与 Spring 框架相关的包，数据库驱动的包，可引入数据库连接池、日志、测试相关包 配置XML，包括数据源 DataSource （用于指定数据库连接地址、账号、密码等数据库配置）和 SqlSessionFactory （用于指定 MyBatis 自动载入的 *Mapper.xml） 编写 Entity 类，用来存储数据库查询返回数据，一般而言，成员变量对应数据库表字段名，仅提供 getter/setter 方法 编写 Mapper 接口 与 *Mapper.xml ，Mapper 接口 指定操作名，并规定好传入参数，*Mapper.xml 为数据库操作的 SQL ，id 需要与 Mapper 接口 一致 创建数据库，编写服务，测试 从 Maven 引入 jar 包在 Maven 项目中的 pom.xml 文件增加以下依赖。项目一般还需要增加 log 日志模块、junit 测试模块等，在此 pom.xml 不再赘述。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;dependencies&gt; &lt;!-- Maven Lib --&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring AOP --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spri &lt;!-- Servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql driver --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.39&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建数据库环境因为 MyBatis 框架是解决持久化或者说数据库的问题，因此我们需要配置一下数据库环境。 12345678DROP TABLE IF EXISTS `t_user`;CREATE TABLE `t_user` ( `id` INT(12) NOT NULL AUTO_INCREMENT, `name` VARCHAR(255) NOT NULL, `age` INT(4) DEFAULT 0, `gender` INT(2), PRIMARY KEY(`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8; 配置 sqlSessionFactory 与 DataSource要使用 MyBatis ，至少需要一个 SqlSessionFactoryBean 是用于创建 SqlSessionFactory 的。要配置这个 Factory bean ，放置下面的代码在 Spring 的 XML 配置文件中。我在配置时，将数据库相关的配置都创建了一个独立的 XML 配置文件，然后在 Spring 主配置文件中通过 import 引用。 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- mysql data source --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close" lazy-init="false"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverclass&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;property name="idleConnectionTestPeriod" value="60"/&gt; &lt;property name="testConnectionOnCheckout" value="false"/&gt; &lt;property name="initialPoolSize" value="2"/&gt; &lt;property name="minPoolSize" value="5"/&gt; &lt;property name="maxPoolSize" value="50"/&gt; &lt;property name="acquireIncrement" value="1"/&gt; &lt;property name="acquireRetryAttempts" value="1"/&gt; &lt;property name="maxIdleTime" value="6000"/&gt; &lt;property name="maxStatements" value="0"/&gt; &lt;/bean&gt; &lt;!-- SqlSessionFactory --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!-- Mapper文件存放的位置，当Mapper文件跟对应的Mapper接口处于同一位置的时候可以不用指定该属性的值 --&gt; &lt;property name="mapperLocations" value="classpath*:sqlmap/*.xml"/&gt; &lt;/bean&gt; &lt;!-- DAO Mapper --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="annotationClass" value="org.springframework.stereotype.Repository" /&gt; &lt;!-- 扫描器开始扫描的基础包名，支持嵌套扫描 --&gt; &lt;property name="basePackage" value="com.test.dao.mapper" /&gt; &lt;/bean&gt;&lt;/beans&gt; 以上是 my-db.xml 配置文件，主要分为三部分: datasource ，数据源，与数据库连接相关，配置数据库的地址、账户、密码，一些配置等等，从 jdbc.properties 文件中载入。关于 Spring 如何载入 properties 文件如何实现，不在这篇文章赘述了。 sqlSessionFactory ，数据库会话工厂。从 *Mapper.xml 中文件自动载入 Mapper 类 ，在此配置中采用 Scanner 方式，自动从 mapper 包内载入 mapper 类。 调用 MyBatis 框架创建 Entity，映射 Database 表（或有）在 entity 包中创建实体，对应 t_user 表 的返回。成员变量一般与数据库表字段名一一对应，成员方法仅提供 getter/setter 方法。 实体类不是必须的，MyBatis 提供将数据库返回简单的映射到 Map 或 HashMap 结构中，而非 POJO 中。 123456789101112131415161718/** * t_user 表实体 */public class User implements Serializable &#123; private int id; private String name; private int age; private int gender; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getGender() &#123; return gender; &#125; public void setGender(int gender) &#123; this.gender = gender; &#125;&#125; 创建 DAO/Mapper在 dao.mapper 包内创建 UserMapper 接口 ，并添加 @Repository 注解 12345@Repositorypublic interface UserMapper &#123; public List&lt;User&gt; findUserById(int id); public Integer insertUser(User user);&#125; 对应具体数据库的方法，例如插入用户、通过 id 查找用户。每次需要定义一个数据库操作，就在 Mapper 类中定义一个接口。 注意，因为在三、配置 sqlSessionFactory 与 DataSource ，定义了自动载入 Mapper 类 。因此，需要加入了 @Repository 的注解，用于标注数据访问组件，即DAO 组件。否则不需要 @Repository 注解，但需要在 *Mapper.xml 中增加 配置。 配置 Mapper.xml在 Mapper.xml 中编写具体的数据库操作的 SQL。 其中，tag 有 insert, select, update 等 id 与 Mapper 接口方法名一一对应； parameterType 为传入参数，可以是 POJO，也可以是 int、String 这种基本类型，SQL 中的参数用 #{id} 的形式表示； resultType 或者 resultMap ，都是存储返回的结果集，其中 resultMap 比较强大，灵活；resultType 可以简单指定为 map 或者 POJO。 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.test.dao.mapper.UserMapper"&gt; &lt;!--配置一个resultMap 指定返回的类型 --&gt; &lt;resultMap id="userInfo" type="com.test.entity.User"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;result column="age" property="age"/&gt; &lt;result column="gender" property="gender"/&gt; &lt;/resultMap&gt; &lt;select id="queryUserInfos" resultMap="userInfo" parameterType="java.lang.Integer"&gt; SELECT * FROM t_user WHERE age = #&#123;age&#125; ORDER BY id DESC; &lt;/select&gt; &lt;insert id="insertUserInfo" parameterType="com.test.entity.User"&gt; INSERT INTO t_user(name, age, gender) VALUES (#&#123;userName&#125;,#&#123;age&#125;,#&#123;gender&#125;) &lt;selectKey resultType="int" keyProperty="id"&gt; SELECT LAST_INSERT_ID(); &lt;/selectKey&gt; &lt;/insert&gt;&lt;/mapper&gt; 关于 *Mapper.xml文件的配置，详情参考官方文档 通过服务调用已经完成上述配置和接口等编写后，就可以在服务中调用了。 12345678910111213141516@Service(value = "userService")public class UserServiceImpl implements UserService&#123; @Autowired private UserMapper userMapper; @Override public List&lt;User&gt; getUser(Integer id) &#123; List x = userMapper.findUserById(id); return x; &#125; @Override public Integer addUser(User user) &#123; return userMapper.insertUser(user); &#125;&#125; 在系统设计时，不会让服务直接就去调用如此底层的操作，往往会增加一个 model 层或者 controller 层。调用方法还是一致的，都是先注入 Mapper 接口，然后调用接口方法就可以了。 #参考资料 MyBatis 与 Spring 集成，官网 http://www.mybatis.org/spring/zh/getting-started.html MyBatis 官网，配置和使用介绍，http://www.mybatis.org/mybatis-3/zh/configuration.html SSM框架——详细整合教程（Spring+SpringMVC+MyBatis），作者 shu_lin，http://blog.csdn.net/zhshulin/article/details/37956105]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简介Ubuntu下Apache服务器的安装]]></title>
      <url>%2F2015%2F10%2F%E7%AE%80%E4%BB%8BUbuntu%E4%B8%8BApache%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
      <content type="text"><![CDATA[本日志主要记录Apache 在Ubuntu 下的安装 方法一：Apt安装apt-get1sudo apt-get install apache2 完成后，通过修改1/etc/apache2/apache2.conf 来完成配置 方法二：使用Apache源代码编译安装下载Apache 的源代码从Apache 官网或其他可用源处下载Apache 的源代码 http://httpd.apache.org/download.cgihttp://apache.etoak.com//httpd/httpd-2.4.3.tar.gz 此链接为Apache 项目的官网，可获得Apache 服务器的多种版本，包括稳定版和 Beta 版等。此次选择下载了httpd-2.4.3.tar.gz 文件。 解压文件下载完毕后得到httpd-2.4.3.tar.gz 文件，下一步需要对其进行解压。Linux 解压命令功能较为强大，可以直接选择解压至安装路径也可以先解压至指定路径，之后再复制到安装路径。直接安装, 输入命令：1sudo tar zxvf httpd-2.4.3.tar.gz -C /usr/local/ //将Apache源文件解压至/usr/local/目录下 Tar为归档文件压缩和解压指令 -z 是配合解压.GZ的-x 解开一个包文件-v 显示详细信息-f 必须，表示使用归档文件 输出：123456789101112…httpd-2.4.3/docs/manual/howto/htaccess.html.ja.utf8httpd-2.4.3/docs/manual/howto/htaccess.html.ko.euc-krhttpd-2.4.3/docs/manual/howto/htaccess.html.pt-brhttpd-2.4.3/docs/manual/howto/index.html……httpd-2.4.3/docs/manual/howto/ssi.html.enhttpd-2.4.3/docs/manual/howto/ssi.html.frhttpd-2.4.3/docs/manual/howto/ssi.html.ja.utf8httpd-2.4.3/docs/manual/howto/ssi.html.ko.euc-krhttpd-2.4.3/docs/manual/faq/index.html… 切换至/usr/local/httpd-2.4.3 目录下查看。输入指令：12cd /usr/local/httpd-2.4.3ls 输出：12345678910111213141516171819202122232425262728293031323334353637383940wang@Wang-Satellite-M300:/usr/local/httpd-2.4.3$ ls -ltotal 1568-rw-r--r-- 1 501 staff 13507 Mar 29 2011 ABOUT_APACHE-rw-r--r-- 1 501 staff 22850 Jul 23 23:20 acinclude.m4-rw-r--r-- 1 501 staff 63038 Jan 31 2012 Apache-apr2.dsw-rw-r--r-- 1 501 staff 77169 Nov 19 2011 Apache.dsw-rw-r--r-- 1 501 staff 9907 Dec 18 2009 apache_probes.d-rw-r--r-- 1 501 staff 2512 Dec 22 2008 ap.ddrwxr-xr-x 6 501 staff 4096 Nov 22 20:56 build-rw-r--r-- 1 501 staff 2644 Aug 24 2007 BuildAll.dsp-rw-r--r-- 1 501 staff 2724 Nov 12 2011 BuildBin.dsp-rwxr-xr-x 1 501 staff 6791 Jan 17 2011 buildconf-rw-r--r-- 1 501 staff 118884 Aug 18 01:05 CHANGES-rw-r--r-- 1 501 staff 12567 Apr 17 2012 config.layout-rwxr-xr-x 1 501 staff 956655 Aug 18 01:20 configure-rw-r--r-- 1 501 staff 27680 Jul 23 23:20 configure.indrwxr-xr-x 9 501 staff 4096 Nov 22 20:56 docs-rw-r--r-- 1 501 staff 403 Nov 22 2004 emacs-style-rw-r--r-- 1 501 staff 4124 Jun 12 2008 httpd.dsp-rw-r--r-- 1 501 staff 17556 Aug 18 01:20 httpd.specdrwxr-xr-x 2 501 staff 4096 Nov 22 20:56 include-rw-r--r-- 1 501 staff 5083 Aug 16 20:42 INSTALL-rw-r--r-- 1 501 staff 2909 Nov 15 2011 InstallBin.dsp-rw-r--r-- 1 501 staff 4142 Dec 16 2010 LAYOUT-rw-r--r-- 1 501 staff 20486 Jan 31 2012 libhttpd.dsp-rw-r--r-- 1 501 staff 25852 Jul 24 2011 LICENSE-rw-r--r-- 1 501 staff 9532 Jan 23 2012 Makefile.in-rw-r--r-- 1 501 staff 46658 Apr 21 2012 Makefile.windrwxr-xr-x 26 501 staff 4096 Nov 22 20:56 modules-rw-r--r-- 1 501 staff 550 Jul 19 14:48 NOTICE-rw-r--r-- 1 501 staff 13681 Mar 16 2012 NWGNUmakefiledrwxr-xr-x 7 501 staff 4096 Nov 22 20:56 os-rw-r--r-- 1 501 staff 5158 Feb 20 2012 README-rw-r--r-- 1 501 staff 5572 Apr 23 2010 README.platforms-rw-r--r-- 1 501 staff 10184 Oct 31 2010 ROADMAPdrwxr-xr-x 3 501 staff 4096 Nov 22 20:56 serverdrwxr-xr-x 2 501 staff 4096 Nov 22 20:56 srclibdrwxr-xr-x 4 501 staff 4096 Nov 22 20:56 supportdrwxr-xr-x 2 501 staff 4096 Nov 22 20:56 test-rw-r--r-- 1 501 staff 8183 Mar 1 2007 VERSIONING 在开始编译 Apache 源文件时需要配置一下，主要是设定编译好的文件的路径。但是，在第一次配置中出现了错误，系统提示需要 apr 和 apr-util 两部分，因此，先配置安装这两个部分。 安装 apr 和 apr-util 并配置从Apache 官网下载apr 和apr-util 两个文件以下为官网推荐的镜像下载地址， apr 下载地址apr-util 下载地址 输入指令：12sudo tar zxvf apr-1.4.6.tar.gz -C /usr/local/sudo tar zxvf apr-util-1.5.1.tar.gz -C /usr/local/ 配置 apr 和 apr-util 两个文件首先进入到 apr 解压后的目录下，用cd命令。输入指令：1./configure –prefix=/usr/local/apr //意思是将编译后的apr文件的顶层路径设为/usr/local/apr 然后开始编译apr，编译过程同其他编译。输入：12makemake install 然后是apr-util的配置和编译。apr-util 的配置和 apr 配置大同小异，但由于其对 apr 有依赖，因此需要比 apr 多了一项配置要求。首先进入 apr-util 解压至的目录下输入：1sudo ./configure --prefix=/usr/local/apr-util --with-apr=/usr/local/apr-1.4.6 &gt; ~/apr-util.txt 然后开始编译输入：12makemake install 注意：有时有的系统还需要 pcre，下载地址下载后的编译和安装都差不多，不再赘述。这里我直接用 apt 安装了 pcre输入：1sudo apt-get install libpcre3-dev 配置apache进入到解压后的 httpd-2.4.3 目录下。配置输入：1sudo ./configure --prefix=/usr/local/apache2 --with-apr=/usr/local/apr-1.4.6 --with-apr-util=/usr/local/apr-util-1.5.1 --enable-so &gt; ~/apache2.txt 这里是最基本的 Apache 配置，除此之外还可以配置模块和其他细节。Apache 在该配置下默认为最小安装。更多 configure ，可以参考 http://apache.jz123.cn/programs/configure.html然后是 make 和 make install。安装完毕。进入到 bin 目录，执行./apachectl start，如果一切安装顺利，可以看到：It works。对于原来的apr-1.4.6，apr-util-1.5.1 和httpd-xx 等文件夹可以视需要来决定是否删去。]]></content>
    </entry>

    
  
  
</search>
